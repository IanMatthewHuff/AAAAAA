AAAAAA
======

Automated Abstract Art Assembly And Appreciation

Guiding Principals

1. Have Fun!
2. Focus On Learning
3. Forward Progress
4. Big Goals

Overview
========

This document is an overview of the very top level scenarios for AAAAAA. It covers both how I want this project to evolve and end up, as well as my guiding principals for development. It doesn't cover design or implementation, even at a high level.

Guiding Principals
==================

When I'm confronted with a choice, these are the principals that I go back to help make my choice.

	Have Fun!
	=========

	Fun above everything else. If I'm not enjoying a hobby coding project, then I'm not going to keep up with it. Obviously there will be times of frustration. But I have to enjoy the general work and process if I ever expect to get anywhere with this.

	Focus On Learning
	=================

	A big point of this project for me is to focus on improving my skills and expanding my knowledge. As an example, I could probably work the fastest with this by staying within my Microsoft programming stack experience. However I want to learn and expand here, so I'm working with Linux and looking at doing some parts of this in Python. I want to do things "correct," but in the face of several reasonable choices I'll often go with the unfamiliar one to learn more. 

	Forward Progress
	================

	Having small goals to continue to move forward on is key here. It's super important with a project like this that I have small items that I can sit down and knock out in an hour or so, check in, and have them completed. Feeling like I'm losing momentum is killer for a project that you have to keep up in your spare time. This also means a focus on getting things working quickly so that I can play and tweak with them.

	Big Goals
	=========

	This project might not ever amount to anything more than a small side project. But part of what provides that important momentum that I mentioned in the Forward Progress section is the feeling that it might lead to something big. If you don't feel like there is something really cool at the end of any large stage of development, then it's going to be hard to keep going. Even if I never get there I want to go ahead and think about how this would work and make money as a fully featured product.

 Overview
 ========

 Automated Abstract Art Assembly And Appreciation is the name of the program. What I'm envisioning is a multi part part process to create and sell really compelling computer generated backgrounds and modern art. The key point here is that the creation of this art will involve a highly flexible (and random generation) creation program to create lots of very different images very quickly. Then on the other side we have an program that can read in images and tries to find out which ones are compelling art work. The two processes are divorced from each other, aside from passing over the image data, so while the assembly program might create 3D models and use OpenGL to create an image, the appreciation program will only have the actual 2D image data to work with. This separation allows for the creation of "happy accidents." In this respect I'm trying to mimic nature. Take rocks that are washed up on the seashore. There could be millions of rocks, all made from different materials, shaped by different waves, and of all different ages. Then have a few people comb the shore and tell them to pick out "pretty" rocks. They don't know how they were created, but people have similar ideas about what would make a rock "pretty." With a computer we can ramp up the speed on these processes. So with a big run my assembly program could create 100,000 different images, based on all types of data and inputs. Then my appreciation programs could run on those images to try to separate the wheat from the chaff and to pick out images that would look the most interesting due to colors / patterns, ect...

 The next part of this work is how to share out and sell these images. In a way it's a bit silly to plan for this, as my goal here is learning, and I doubt that it would ever really get to that point. But at the same time, part of the learning and practice here is figuring out how smart startups interact with users, sell to customers, and build a brand. One aspect would be using web sites (perhaps existing ones like ImageKind) to sell prints and posters of the art. Also T-Shirts or other clothes could be created to sell. The actual end goal that I find interesting would be a site to actually sell raw image files very cheaply on-line, perhaps with the ability to provide some basic input from the buyer. By selling super cheaply "Art for a buck!" we poke a bit of fun at how "limited" prints usually work with art (especially since we provide users with a totally unique piece). And we raise the possibility that if this every breaks incredibly well money could be made by selling super cheaply to many. Another possibility would be being able to create customized art for something like Starbucks cups, where each could be a cool, unique image.

 	Assembler
 	=========

 	The assembler is the program that needs to generate the art. The key point here is to allow everything to be as flexible as possible so that we can get enough randomization to create enough unique looks. So a specific program might want to place objects all over the screen. It should request the objects from a separate program and the placement on screen could be defined by many different functions, sets of data, or specific random generation patterns. The general program would say place object X in pattern Y with colors Z. And a specific generation instance would place triangles in a spiral pattern with the colors blue and white. The full set of stages needed to generate an image will be called a pipeline and we should keep these as flexible as we can. I see working with Python (for learning / clarity) and C++ (for OpenGL / speed) and being able to combine stages from different languages. For example a C++ OpenGL tint stage could tint all the pixels of a Python program that outputs a bitmap as a final stage.

 	Input to the Assembler should start with a specification of target resolution (so we can make specific sizes for any use) and with the number of images to generate and a formula for how to create the pipelines. Our specification for the pipelines should be able to allow for either manual specification or random choice for the various stages. This way we can choose to either go full random, or to specify just small specific areas to randomize. Pipelines can also contains a description and a thumbnail, as well as version information so that if we ever choose to later add a UI for creating art we have that info available. At the start pipelines will create a single image from a run, and each stage is just a black box to compose. But soon into development I want the ability to create sets of images that evolve over time. So these will need their own special type of pipeline that keeps a block of storage memory around, and then takes a set of images at specific steps in the process. This could be really cool for showing evolving sets of images that grow / changes on a specific algorithm.

 	When processing the pipelines we have a really good way to optimize for multi-threading. Each pipeline can be considered a fully independent task that takes an input and outputs an image. So with a simple thread pool we should be able to execute multiple pipelines at the same time.  

 	Output from the Assembler should be a folder full of images that can later be operated on by the Appreciator. Seems the simplest to have an output to disk mode to start, especially since we want to appreciate in batches.

 	Appreciator
 	===========

 	The Appreciator is the program that processes image files looking for specific images that are appealing to the human eye. As mentioned above, a big point with this process is that the Appreciator should not have knowledge of the Assembler internals. This way specific algorithms could be used to assemble artwork in 3D, which is then printed out to a 2D image, where it is looked at just as a 2D image. It lets us find those happy accidents that I hope will be the linchpin of this project.

 	Input to the Appreciator will be folders full of images needed to process. Just as with the Assembler, I'd like the Appreciator to be as modular and programmable as possible when doing its work. For example, you could choose to run just one specific Appreciator patron (I'm considering a patron to be like a single museum patron, representing on specific "opinion" on art pieces) on all the image and take the top X. Or you could run multiple patrons of all different type on the image, then take some weighted combination of them.

 	At a basic level, a patron could be something as simple as "likes the color blue" to start out with. As they grow more complex, I'm hoping to use more computer vision techniques to pick out things like locations of objects and edges to be able to apply critiques of arrangement and symmetry to them. 