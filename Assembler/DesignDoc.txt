This file is my Design Document for the Assembler. More specific comments can be found in each code file, but this file has a better overview of the entire application as well as the relationships between all of the key classes involved.

main 
====

The main file is just to create an Assembler instance and pass any needed startup data to it. We should not be doing anything big here.

Assembler
=========

The assembler is the heart of the program here. The assembler first processes the input data into a run specifications for what it needs to create. The run specification will end up as a set of "pipelines" a pipeline details the entire set of components and data that will go into creating one specific image. Each pipeline part provides the possible inputs that are allowed into it as well as the output that it produces. Using those inputs and outputs we can create a valid chain for image generation. When the list is complete we start to pick items off of the list and spin up new threads to process them up to a set thread limit.

The Assembler needs knowledge of all the available Pipeline Stages so they can report back to input (via file or command line or eventually UI) what the various options are. It also needs to be able to take input from the user (via file, cmd, or UI) and match it up against the various available stages to make sure that it is valid.

	Key Data:
	Stages - A collection (probably unordered map on Stage.ID) of all the Stages currently available to the program.
	IAssemblerIO - An AssemblerIO class to manage input and output from the main Assembler
	Run - The current Run being processed. 

AssemblerIO
===========

AssemblerIO is used by the Assembler to control input and output from the user. Currently this will involve command line input reading and writing to allow the user to control the Assembler. Later this might also move to file runs or eventually UI control.

Run
===

Input from the user needs to be processed into a full run specification of what Pipelines to run and how many of them. 

Pipeline
========

A Pipeline object holds all of the various pipeline stages and is responsible for passing the data from one stage to the next. At the start we'll just have static Pipelines which create a single image. But later on we will also have Dynamic Pipelines which contains a set of shared data and stages are allowed to operate on it in steps to create a set of related images.

Pipeline Stage
==============

The key point with a pipeline stage is that it should have a well defined set of inputs (with the ability to also have random choice or default values) and a well defined output. A pipeline could be input a set of random integers and then output a set of vertex points, or input image data and output shaded image data, and so on. Note that multiple inputs and (possibly?) outputs are possible with any one Stage. We might need both a random number generator and a vertex provider into a specific stage.

By default Stages are C++ code, however I would like the chance to also host Python stages within a C++ "stage wrapper" for ease and speed of implementing some of the stage contents.

	Key Data:
	ID - We need a unique ID for each Stage
	Name - A friendly name for the Stage
	Description - A bit of information about what the stage does may be user visible
	Version - Stages will be upgraded and changed over time, we need to track this